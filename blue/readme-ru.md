# Руководство по сборке внутренней DLL для Roblox, подобной BlueFire

**Дисклеймер:** Это руководство предоставлено исключительно в образовательных и информационных целях. Оно предназначено для демонстрации концепций программирования, процессов сборки программного обеспечения и техник интеграции в средах C++ и .NET. Автор не поощряет и не одобряет любые формы читерства, эксплуатации или нарушения условий обслуживания Roblox, целостности игр или каких-либо законов. Неправильное использование этой информации, включая создание или распространение читов для онлайн-игр, может привести к блокировке аккаунтов, юридическим последствиям или другим санкциям. Действуйте на свой страх и риск и убедитесь, что все действия соответствуют применимым законам и политикам платформ.

## Введение

Это руководство описывает шаги по сборке кастомной внутренней DLL для Roblox, подобной "BlueFire", которая обычно используется для инъекции скриптов или модификации поведения игры в Roblox. Процесс предполагает, что у вас есть доступ к исходному коду проекта (например, проекту DLL на C++ в Visual Studio), похожему на структуру BlueFire. Вам нужно обновить оффсеты и шаффлы на основе последней версии Roblox, переименовать проект, собрать его и интегрировать в приложения .NET, такие как Windows Forms или WPF.

Предварительные требования:
- Visual Studio 2022 (или новее) с установленными workloads для C++ и .NET.
- Базовые знания C++, оффсетов в хакинге памяти и .NET (C#).
- Установленный Roblox для тестирования (используйте ответственно).
- Исходный код похожего проекта DLL (не предоставляется здесь; предполагается, что он у вас есть).

## Шаг 1: Установка OpenSSL для C++

OpenSSL часто требуется для криптографических операций в таких проектах (например, для обработки зашифрованных состояний или коммуникаций). Установите его через vcpkg (рекомендуется для удобства) или вручную с официального сайта.

### Вариант 1: Использование vcpkg (Рекомендуется)
1. Установите vcpkg, если ещё не установлено:
   - Клонируйте репозиторий: `git clone https://github.com/microsoft/vcpkg.git`
   - Запустите bootstrap: `.\vcpkg\bootstrap-vcpkg.bat`
   - Интегрируйте с Visual Studio: `.\vcpkg\vcpkg integrate install`

2. Установите OpenSSL:
   - Запустите: `.\vcpkg\vcpkg install openssl:x64-windows` (для 64-бит; скорректируйте для вашей архитектуры).

3. В Visual Studio:
   - Откройте проект.
   - Перейдите в Project > Properties > C/C++ > General > Additional Include Directories: Добавьте `$(VCPKG_ROOT)\installed\x64-windows\include`.
   - Linker > General > Additional Library Directories: Добавьте `$(VCPKG_ROOT)\installed\x64-windows\lib`.
   - Linker > Input > Additional Dependencies: Добавьте `libcrypto.lib;libssl.lib`.

### Вариант 2: Ручная установка с официального сайта
1. Скачайте последнюю версию OpenSSL с https://www.openssl.org/source/ (например, openssl-3.x.x.tar.gz).
2. Распакуйте и соберите:
   - Установите Perl (например, Strawberry Perl) и NASM (Netwide Assembler).
   - Запустите в командной строке: `perl Configure VC-WIN64A` (для 64-бит).
   - Затем: `nmake` и `nmake install`.
3. Скопируйте папки `include` и `lib` в ваш проект или системный путь.
4. Обновите свойства Visual Studio, как в Варианте 1, указав пути к вашей установке OpenSSL.

Протестируйте, включив `<openssl/evp.h>` в код и скомпилировав простой тестовый файл.

## Шаг 2: Обновление оффсетов и шаффлов

Оффсеты и шаффлы — это адреса в памяти и определения макросов, указывающие на конкретные функции или данные в исполняемом файле Roblox. Они меняются с обновлениями Roblox, поэтому вы должны заменить их в файлах `Offsets.hpp` и `Shuffles.hpp` вашего проекта на основе предоставленных данных.

### Из предоставленных файлов
- `! OFFSETS&SHUFFLES.txt`: Содержит старые оффсеты (например, для version-4aeb17bd13994560) и шаффлы. Используйте как参考 для структуры.
- `Shuffles.txt`: Обновлённые шаффлы для version-b591875ddfbc4294.
- `Offsets.txt`: Обновлённые оффсеты для version-b591875ddfbc4294.

### Процесс замены
1. Откройте `Offsets.hpp` (или аналогичный файл) вашего проекта.
   - Скопируйте оффсеты из `Offsets.txt` (например, `const uintptr_t Print = REBASE(0x14CD600);`).
   - Замените все старые оффсеты на новые. Убедитесь, что макрос `REBASE(x)` определён правильно (например, `#define REBASE(x) x + (uintptr_t)GetModuleHandle(nullptr)`).
   - Обновите пространства имён, такие как `Update`, `RBX` и т.д., с новыми значениями для функций вроде `LuaVM__Load`, `Task__Defer` и т.д.
   - Для DataModel, Instance и т.д. обновите константы, такие как `Name = 0x68;`.

2. Откройте `Shuffles.hpp` (или аналогичный).
   - Скопируйте макросы шаффлов из `Shuffles.txt` (например, `#define LUAU_SHUFFLE3(s, a1, a2, a3) a2 s a3 s a1`).
   - Если ваш проект использует старые шаффлы из `! OFFSETS&SHUFFLES.txt` (например, `#define LUAU_SHUFFLE3(s, a1, a2, a3) a3 s a2 s a1`), замените их полностью на новые.
   - Убедитесь, что разделители вроде `LUAU_COMMA_SEP` и `LUAU_SEMICOLON_SEP` совпадают.

3. Если в вашем проекте есть дополнительные шаффлы (например, для Proto, LSTATE), интегрируйте из `! OFFSETS&SHUFFLES.txt`, такие как `#define PROTO_MEMBER1_ENC VMValue0`.

4. Проверьте:
   - Скомпилируйте проект на наличие ошибок.
   - Используйте инструмент вроде Cheat Engine для валидации оффсетов в запущенном процессе Roblox.

Примечание: Оффсеты зависят от версии. Для текущей даты (28 октября 2025 года) используйте последние из надёжных источников или дампьте их сами с помощью инструментов вроде Hyperion dumper.

## Шаг 3: Переименование всех ссылок на "BlueFire" в Visual Studio

Чтобы ребрендировать DLL (например, на "MyCustomDLL"):
1. Откройте решение в Visual Studio.
2. Используйте "Find and Replace" (Ctrl + H):
   - Найти: "BlueFire" (с учётом регистра, целое слово).
   - Заменить: "MyCustomDLL".
   - Область: Всё решение.
   - Включить: Все типы файлов (например, .cpp, .hpp, .csproj, если смешанный).

3. Переименуйте файлы:
   - Правой кнопкой мыши на проект > Rename.
   - Обновите .sln, .vcxproj и имя выходной DLL в Properties > Application > Assembly Name/Output File.

4. Обновите пространства имён, имена классов и строки в коде (например, эндпоинты API вроде "http://localhost:1337/Bluefire/Scheduled" на ваше новое имя).
5. Очистите и пересоберите, чтобы убедиться, что ничего не осталось.

## Шаг 4: Сборка проекта

1. Откройте проект в Visual Studio.
2. Установите конфигурацию: Release > x64 (для совместимости с Roblox).
3. Разрешите зависимости: Убедитесь, что OpenSSL связан, и любые другие библиотеки (например, Windows.h).
4. Соберите: Build > Build Solution (Ctrl + Shift + B).
   - Выход: Файл .dll (например, MyCustomDLL.dll) в папке bin/Release.
5. Протестируйте: Инжектьте в Roblox с помощью простого инжектора (не описывается здесь; используйте ответственно).

Общие проблемы:
- Ошибки линкера: Проверьте пути к библиотекам.
- Ошибки компилятора: Исправьте типы оффсетов (например, uintptr_t vs. uint64_t).

## Шаг 5: Использование в приложениях Windows Forms и WPF через API

После сборки интегрируйте DLL в приложение .NET для инъекции и выполнения. Предполагается, что ваша DLL предоставляет API (например, через HTTP-сервер на localhost:1337 для планирования скриптов).

### В Windows Forms или WPF (C#)
1. Создайте новый проект .NET (Windows Forms App или WPF App).
2. Добавьте ссылки: System.Net.Http, Newtonsoft.Json.
3. Для прикрепления (инъекции):
   - Используйте Process.Start для запуска исполняемого инжектора, bundled с вашим приложением.
   ```csharp
   using System.Diagnostics;
   using System.IO;

   // В событии клика кнопки или методе
   Process.Start(Path.Combine(Environment.CurrentDirectory, "Main\\Injector.exe"));
   ```

4. Для выполнения (отправка скрипта в API DLL):
   - Предполагается, что ваш редактор — TextBox (например, this.editor.Text).
   ```csharp
   using System.Net.Http;
   using System.Text;
   using Newtonsoft.Json;
   using System.Windows; // Для MessageBox в WPF

   // В асинхронном событии клика кнопки
   private async void ExecuteButton_Click(object sender, RoutedEventArgs e) // Пример для WPF
   {
       StringContent content = new StringContent(JsonConvert.SerializeObject(new { Script = this.editor.Text }), Encoding.UTF8, "application/json");
       try
       {
           using (HttpClient Client = new HttpClient())
           {
               HttpResponseMessage httpResponseMessage = await Client.PostAsync("http://localhost:1337/MyCustomDLL/Scheduled", content); // Обновите эндпоинт
           }
       }
       catch (Exception ex)
       {
           MessageBox.Show("Request failed: " + ex.Message);
       }
   }
   ```

5. Запустите приложение: Соберите и выполните. Сначала прикрепите, затем отправьте скрипты.

Эта настройка позволяет управлять инжектированной DLL через HTTP для безопасности/разделения.

## Заключение

Теперь вы собрали и интегрировали кастомную внутреннюю DLL для Roblox. Помните, это для обучения — всегда уважайте разработчиков игр и сообщества. Для обновлений мониторьте версии Roblox и передампьте оффсеты по мере необходимости.
